<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
	name="viewport">
<link rel="stylesheet" href="slides.css">
<script src="reveal/lib/js/head.min.js"></script>

<title>Cockpit: A Linux Session in your Browser</title>
</head>
<body>

<div class="reveal">
<div class="slides">

	<!-- INTRO -->
	<section>
		<img src="logo.png">
		<aside class="notes">
		</aside>
	</section>

	<section>
		<h2>Cockpit is a<br>
			<strong>Linux admin interface</strong></h2>
	</section>

	<section>
		<h2>Cockpit is a<br>
			<strong>remote interactive</strong><br>
			Linux admin interface</h2>
		<aside class="notes">
			<ul>
				<li>Cockpit is a *remote interactive* admin interface</li>
				<li>Cockpit runs in a browser and is accessible remotely. Most
				server and systems are headless. It's interactive, you perform
				admin tastks interactively, troubleshoot, configure and so on.</li>
		</aside>
	</section>

	<section>
		<img src="cockpit-system.png">
		<aside class="notes">
			<ul>
				<li>Looks like this, but you've probably seen it already.</li>
			</ul>
		</aside>
	</section>

	<section>
		<h2><strong>Zero footprint</strong></h2>
		<aside class="notes">
			<ul>
				<li>No phat NodeJS or PHP server side deps.</li>
				<li>Starts on demand, exits when not in use.</li>
			</ul>
		</aside>
	</section>

	<section style="text-align: left;">
		<h1>Goals:</h1>
		<h2>
			<em><strong>1.</strong> Linux <strong>usable</strong><br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				by non-expert admins</em><br>
			<br>
			<em><strong>2.</strong> Complex Linux features<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<strong>discoverable</strong></em>
		</h2>
	</section>

    <section>
		<h2><strong>RPM OSTree</strong></h2>
		<p>Software updates on Atomic Hosts</p>
    </section>

    <section>
		TODO: VIDEO
		<aside class="notes">
			Atomic uses rpm-ostree to create ostree repositories out of RPMs. Cockpit
			shows you the currently installed RPMs as well as gives you option to rollback
			to a previously state. We can also check for new versions, see what packages will
			be changed and deploy those changes.
		</aside>
    </section>

    <section>
		<h2><strong>Issues</strong></h2>
		<aside class="notes">
			Working on this UI surfaced a few issues with rpm-ostree that needed
			to be fixed in order to make this UI possible.
		</aside>
    </section>

    <section>
        <h2>Multi-User safety</h2>
        <p class="fragment">DBUS Api and OSTree locking</p>
		<aside class="notes">
			The rpm-ostree command was not safe for multiple users. Users couldn't know what others were doing on the system and could end up with a corrupted system if certain actions were performed at the same time. A DBUS library rpm-ostree  to manage ostree a DBUS API that made it possible to provide information on the status of the system as well as ostree level locking to prevent potentionaly corrupting actions. These changes made it possble also made it possible for cockpit to provide a detailed look at the potentional changes an action would cause as well as the ability to react to changes made by other login sessions.
		</aside>
    </section>

    <section>
        <img src="upgrade-non-idempotent.png">
		<aside class="notes">
			The rpm-ostree command was not idempotent. It wasn't possible to be sure exactly what changes you were deploying depending on when the repo you are pulling from got updated. This could be a problem for multiple machines trying to upgrade in sync or in the case of cokcpit on a single machine we couldn't be sure that the exact changes that are displaying to the user is in fact what will be deployed.
		</aside>
    </section>

    <section>
        <img src="deploy-idempotent.png">
		<aside class="notes">
			The solution was to add a new verb deploy that would allow you target a
			specfic version or hash. Cockpit can show those change diffs with confidence
			and ensure that only those changes are deployed when the user applies them.
		</aside>
    </section>

    <section>
		<h2>Want useable APIs?<br><strong>Add them to cockpit</strong></h2>
		<aside class="notes">
			Going through the process of adding a new UI to cockpit won't only give you a nice interface web interface but i can really help surface usablity issues with the underlying API or command. In this case not only do cockpit users now have a nice easy way to upgrade their systems. Terminal users also have commands that are safer and easier to reason about.
		</aside>
    </section>

    <section style="text-align: left">
		<h2><strong>Still to come</strong></h2>
	    <ul style="margin-left: 50px; text-align: left">
	    	 <li>Deploying arbitrary versions</li>
	        <li>Rebase support</li>
	        <li>Improve multi-OS support</li>
	    </ul>
		<aside class="notes">
			There are more use cases that cockpit should grow support for.
		</aside>
    </section>

    <section>
        <img src="multiple-os.png">
		<aside class="notes">
			RPM OSTree supports having multiple OSes side by side and switching between them. Cockpit needs to surface this
		</aside>
    </section>

    <section>
		<h2><strong>Managing Containers</strong></h2>
		<p>with Kubernetes/Openshift</p>
		<aside class="notes">
			Last year we added a Kubernetes/Openshift UI in Cockpit.
		</aside>
    </section>

    <section>
        <h2><strong>Kubernetes:</strong><br> Container Orchestration</h2>
        <h2><strong>Openshift:</strong><br> Kubernetes+</h2>
		<aside class="notes">
			Quick review: Kubernetes is a container orchestration system that handles
			scheduling and management of docker containers. Openshift is built on top
			of Kubernetes and provides additonal deployment, orchestration, and routing
			functionality.

		    Just for the sake of simplicity instead of saying kubernetes / openshift everywhere
		    I'm just going say kubernetes, unless i'm refering specifically to features
		    only in openshift.
		</aside>
	</section>

    <section>
		<h1>Goals:</h1>
		<h2>
			<em><strong>1.</strong> Make kubernetes features <strong>discoverable</strong></em>
			<br>
			<em><strong>2.</strong> Provide a UI for common <strong>administrative</strong> use cases</em>
		</h2>
		<aside class="notes">
			Note that we don't say anything about developers here. We aren't aiming to provide
			a UI for common developer use cases. There are other tools that are good at that,
			cockpit is primarily a administor tool so that's what we chose to focus on.
		</aside>
	</section>

    <section style="text-align: left">
        <h2><strong>Installation</strong></h2>
        <p>Already running Cockpit on your nodes?</p>
        <ul style="margin-left: 50px; text-align: left" class="fragment">
            <li>Install as a normal cockpit package</li>
            <li>Uses the logged in users api authorizations</li>
        </ul>
        <aside class="notes">
			<ul>
			    <li>So how do get this UI, well are you already running Cockpit on your nodes?.</li>
			    <li>If you are then you can simply install the cockpit kubernetes package (rpm or deb). Like everything else in cockpit, you'll have the same permissions with the kubernetes API as would if you were on issuing commands on the command line. Cockpit will respect your user's kubectl settings.</li>
			</ul>
		</aside>
    </section>

    <section style="text-align: left">
        <h2><strong>Installation</strong></h2>
        <p>Without Cockpit on your nodes?</p>
        <ul style="margin-left: 50px; text-align: left" class="fragment">
            <li>Install as a stand alone unprivileged Docker container or a Kubernetes Pod</li>
            <li>Uses the logged in users api authorizations</li>
        </ul>

		<aside class="notes">
		    <ul>
		        <li>What if you don't want to install cockpit on any of your nodes,
		        or maybe you want
		    to allow users who have API access to be able to use this UI for managing
		    kubernetes without giving them a user account on the node OS. </li>
		    <li>So there is also the option of deploying cockpit's kubernetes UI as either
		    a stand alone container or kubernetes pod.</li>
        </ul>
	    </aside>
    </section>

    <section>
        <h2>Container Configuration</h2>
        <p>Environment Variables + Downward API
   		<aside class="notes">
   		    <ul><li>
		    The cockpit/kubernetes container looks at environment varibles to know how
		    to connect to the kubernetes master. When running as pod most of what it needs
		    will be automatically populated by the downward API and default secrets.</li>

		    <li>However when doing OAuth with openshift, there are two required variables
		    that right now can't get filled in by the downward API, The public domain or
		    address of the kubernetes master, and the public address or domain that we will
		    use in our browser to access our service.</li></ul>
		</aside>
    </section>
    <section data-background-video="oc-create.webm">
		<aside class="notes">
		    <ul>
            <li>Openshift has a nice template feature that lets you create API object definitions from a template. We can use this to generate the object definitions our cockpit kubernetes service with the correct environment variables filled in.</li>
		    <li>We can pipe these definitions to oc create to actually crete the objects.</li></ul>
		</aside>
    </section>

    <section>
        TODO: LOGIN VIDEO
		<aside class="notes">
		    Now lets hit our newly deployed service in the browser. Right away we get
		    redirected to the our kubernetes master api server. I've configured this one
		    to login users using github as the OAuth provider. So we get redirected to
		    github, logged in and redirected back.

		    You can see this doesn't look like the standard cockpit, that's because we are
		    running just the kubernetes componant none of cockpits other system administration
		    packages are available since this is running in a unpriviledged container
		    isolated from the host system they wouldn't even make sense in this context.
		    To make all this work we refactored cockpit's local login mechnism to make it
		    pluggable, hopefully that will enable more interesting uses of cockpit's componants
		    in the future.`
		</aside>
	</section>

    <section>
        TODO: Video of features.
		<aside class="notes">
            Alright lets take a look at the UI itself. Let's start by uploading a
            a simple service. This just a simple sample app with a redis database and a
            php webserver.

            Pods are what kubernetes schedules and manages. A pods is one or more containers.
            We can inspect our pods, see details about the container it contains, follow the
            logs and even execute commands.

            Replication Controllers are how Pods are managed. We can tell kubernetes how many
            pods we want and it will handle scheduling them on available nodes.

            Since pods come and go, services define a set of pods that can be accessed in a
            stable way, even when the underlying pods change. We check on a services status,
            where it is located and what it exposes.

			Cockpit also provides some nice visualization to help admins see what objects
			are running and how they relate to and interact with each other.
		</aside>
    </section>

    <section>
        TODO: Video of killing service
		<aside class="notes">
            Just to reiterate that we are running in a pod in kubernetes. Here's what it looks like if you kill the kubernetes pod we are running in. First we delete the replication controller so that we don't get respawned, and then delete the pod. And just like that we are disconnected and can't reconnect.
		</aside>
    </section>

    <section style="text-align: left">
        <h2>Coming improvements</h2>
        <ul style="margin-left: 50px; text-align: left" class="fragment">
            <li>Better support for non-cluster admin users.</li>
            <li>Project and User management in openshift</li>
            <li>UI for openshift registry</li>
        </ul>
    </section>

    <section style="text-align: left">
        <h2>Needed Kubernetes Improvments</h2>
        <ul style="margin-left: 50px; text-align: left" class="fragment">
            <li>Discoverable external urls.</li>
            <li>Safer authentication defaults</li>
        </ul>
		<aside class="notes">
            Actually running this on kubernetes isn't . These are some things we'd like to see change upstream in kubernetes/openshift.
            To improve the usability.

            <ul>
                <li>Discoverable external urls: Right now to make OAuth work we have to manually specify what the public urls for our service and the kubeapi master are. Kuberenetes already knowns the master URL so we really shouldn't have to specify that again, but more that that it would be ideal if there was a way to communicate better about external domains / addresses using the downward API so we don't have to specify those manually.</li>
                <li>Better authentication defaults: On openshift origin, the default is to accept any username/password combo. While our container will run with that, it's probably not a good idea to keep it like that in most cases. On kubernetes the api is open by default, our container will refuse to log a user into an open api. So right now to use this with a standard kubernetes install you need to use basic auth. There's been some talk upstream about bringing in some of openshift's OAuth code into kubernetes. That would help make this more usable out of the box.</li>
            </ul>
		</aside>

    </section>


	<section>
		<!-- TODO: Slides from Dominik -->
		...
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		TODO: tuned
		<aside class="notes">
		</aside>
	</section>

	<section data-background-video="tuned.webm">
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<h2>Mooo!</h2>
		<aside class="notes">
			<ul>
				<li>Talk about not shooting cattle</li>
				<li>Troubleshooting</li>
				<li>Using Cockpit with cloud operating systems.</li>
			</ul>
		</aside>
	</section>

	<section>
		<h2><strong>Cockpit</strong> and <strong>Atomic</strong></h2>
		<aside class="notes">
			<ul>
				<li>Parts of Cockpit are included in Atomic.</li>
				<li>Cockpit is not listening on port 9090 on Atomic</li>
				<li>Another one of the things we worked on this year was
					making Cockpit work better with cloud instances.</li>
			</ul>
		</aside>
	</section>

	<section>
		<img src="multi-host-ssh.png">
		<aside class="notes">
			<ul>
				<ul>So how do you access it? Over SSH</ul>
				<ul>cockpit-bridge is spawned over SSH in a real SSH session.</ul>
			</ul>
		</aside>
	</section>

	<section data-background-video="multi-host-ssh.webm">
		<aside class="notes">
			<li>Browsers don't do key auth. It would be awesome if they did.</li>
			<li>Key authentication.</li>
			<li>SSH agent</li>
			<li>There's more ideas in this area. We could make a container like Peter
				was talking about earlier, with SSH keys.</li>
		</aside>
	</section>

	<section>
		<h2><em>Combinatorial Explosion</em></h2>
		<aside class="notes">
			<ul>
				<li>Cockpit talks to tons APIs, from systemd, ssh-agent, file formats, etc.</li>
				<li>Combinatorial explosion</li>
				<li>The would grind to a halt, if we didn't test.</li>
			</ul>
		</aside>
	</section>

	<section>
		<img src="ci-tasks.png">
		<aside class="notes">
			<ul>
				 <li>Real operating systems: Fedora, RHEL, Atomic, Debian</li>
				 <li>Real browsers: Firefox, Chrome</li>
		The code XXX in each PR boots hundreds
		of times before it merges.
				<li>Not just talking about unit testing, we have a couple thousand of those.</li>
			</ul>
		</aside>
	</section>

	<section>
		<h2><strong>10,000</strong> testing instances a day</h2>
		<aside class="notes">
			<ul>
				<li>On busy days we can have up to 10,000 testing instances.</li>
			</ul>
		</aside>
	</section>

	<section data-background="yo-dawg.png" data-background-position="bottom right"
		data-background-size='10em'>
		<h2><strong>Test virtual machines</strong><br>
			run in<br>
			<strong>Docker containers</strong></h2>
	</section>

	<section data-background="01-initial.png" data-background-color="white" data-background-size='100%'>
		<aside class="notes">
			<ul>
				<li>Testing is distributed and can scale up and down.</li>
				<li>You can run it on your laptop and contribute.</li>
				<li>Fedora Project has donated some instances.</li>
				<li>Other random machines we found.</li>
			</ul>
		</aside>
	</section>

	<section data-background="02-tasks.png" data-background-color="white" data-background-size='100%'>
	</section>

	<section data-background="03-logs.png" data-background-color="white" data-background-size='100%'>
	</section>

	<section data-background="04-status.png" data-background-color="white" data-background-size='100%'>
	</section>

	<section>
		<h2>Packaging &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <strong>Upstream</strong></h2>
		<aside class="notes">
			<ul>
				<li>Packaging is upstream.</li>
			</ul>
		</aside>
	</section>

	<section>
		<img src="qe-tasks.png">
		<aside class="notes">
			<ul>
				<li>QE testing is upstream.</li>
			</ul>
		</aside>
	</section>

	<section>
		<h2>Packaging &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <strong>Upstream</strong></br>
		QE Testing &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <strong>Upstream</strong></h2>
		<aside class="notes">
			<ul>
				<li>Packaging is Upstream, when it needs to be testable.</li>
				<li>QE testing is upstream.</li>
			</ul>
		</aside>
	</section>

	<section>
		<!-- TODO: Fix the spacing mess -->
		<h2>Packaging &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <strong>Upstream</strong></br>
		QE Testing &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <strong>Upstream</strong></h2>
		<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CI  &nbsp;&nbsp;=&nbsp;&nbsp; <strong>Upstream</strong></h2>
		<aside class="notes">
			<ul>
				<li>I'd be lying if I said this was easy. Constant care and feeding</li>
				<li>Everyone will probably find bugs, and say our tests suck.</li>
			</ul>
		</aside>
	</section>

	<section>
		<h2><em>Continuous Delivery</em></h2>
		<aside class="notes">
			<li>50 releases of Cockpit this year, most of them stable.</li>
		</aside>
	</section>

	<section>
		<h2><em>Sign a tag</em> &nbsp;&nbsp;&#xf0a9;&nbsp;&nbsp; <em>Becomes a release</em></h2>
	</section>

	<section>
		<ul style="text-align: left; font-size: 1.4em;">
			<li><em>Tarballs</em></li>
			<li><em>Koji</em> scratch build</li>
			<li><em>Fedora</em> commit</li>
			<li><em>Koji</em> build</li>
			<li><em>COPR</em> builds</li>
			<li><em>Debian</em> packaging</li>
			<li><em>Docker Hub</em> containers</li>
			<li><em>Upload documentation</em></li>
		</ul>
	</section>

	<section>
		<h2>The real magic of continous<br>
		happens <strong>before you merge</strong></h2>
		<aside class="notes">
		</aside>
	</section>

	<section>
		<h2><strong>cockpit-project.org</strong></h2>
		<p><tt>#cockpit on Freenode</tt></p>
		<p><tt>github.com/cockpit-project/cockpit</tt></p>
	</section>
</div>
</div>

<script src="reveal/js/reveal.js"></script>
<script src="slides.js"></script>

</body>
</html>
